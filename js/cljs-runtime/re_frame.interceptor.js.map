{"version":3,"file":"re_frame.interceptor.js","sources":["re_frame/interceptor.cljc"],"mappings":"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","names":["context","interceptor","direction","re-frame.interceptor/assoc-coeffect","db","cljs.core.apply.cljs$core$IFn$_invoke$arity$5","cljs.core/update-in","key","f","args","temp__5455__auto__","unknown-keys","cljs.core/seq","clojure.set.difference.cljs$core$IFn$_invoke$arity$2","stack","or__3922__auto__","id","cljs.core/assoc-in","value","re-frame.interceptor/assoc-effect","re_frame.interceptor.context.cljs$core$IFn$_invoke$arity$2","event-v","interceptors","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","not-found","cljs.core.fnil.cljs$core$IFn$_invoke$arity$2","cljs.core/into","re-frame.interop/empty-queue","m","cljs.core/keys","cljs.core/set","re-frame.interceptor/enqueue","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","re-frame.interceptor/mandatory-interceptor-keys","cljs.core.get_in.cljs$core$IFn$_invoke$arity$3","re-frame.trace/is-trace-enabled?","new-trace__34455__auto__","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","cljs.core.update.cljs$core$IFn$_invoke$arity$4","re-frame.trace/*current-trace*","cljs.core/merge","cljs.core/peek","queue","re-frame.interceptor/change-direction","event","re-frame.interceptor/invoke-interceptor-fn","re-frame.interceptor/invoke-interceptors","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","cljs.core/pop","before","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","cljs.core/map?","cljs.core.get.cljs$core$IFn$_invoke$arity$2","re_frame.loggers.console.cljs$core$IFn$_invoke$arity$variadic","re-frame.interop/debug-enabled?","var_args","args__4500__auto__","len__4497__auto__","i__4498__auto__","argseq__4501__auto__","cljs.core/IndexedSeq","re-frame.interceptor/update-coeffect","seq34579","G__34580","cljs.core/first","cljs.core/next","G__34581","G__34582","re-frame.interceptor/execute","G__34573","re-frame.interceptor/get-coeffect","js/Error","after","re-frame.interceptor/->interceptor","p__34537","map__34538","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","seq34529","G__34595","re-frame.interceptor/context","cljs.core/empty?","G__34568","re-frame.interceptor/get-effect","re-frame.interceptor/interceptor?"],"sourcesContent":["(ns re-frame.interceptor\n  (:require\n    [re-frame.loggers :refer [console]]\n    [re-frame.interop :refer [empty-queue debug-enabled?]]\n    [re-frame.trace :as trace :include-macros true]\n    [clojure.set :as set]))\n\n\n(def mandatory-interceptor-keys #{:id :after :before})\n\n(defn interceptor?\n  [m]\n  (and (map? m)\n       (= mandatory-interceptor-keys (-> m keys set))))\n\n\n(defn ->interceptor\n  \"Create an interceptor from named arguments\"\n  [& {:as m :keys [id before after]}]\n  (when debug-enabled?\n    (if-let [unknown-keys (seq (set/difference\n                                (-> m keys set)\n                                mandatory-interceptor-keys))]\n      (console :error \"re-frame: ->interceptor\" m \"has unknown keys:\" unknown-keys)))\n  {:id     (or id :unnamed)\n   :before before\n   :after  after })\n\n;; -- Effect Helpers  -----------------------------------------------------------------------------\n\n(defn get-effect\n  ([context]\n   (:effects context))\n  ([context key]\n   (get-in context [:effects key]))\n  ([context key not-found]\n   (get-in context [:effects key] not-found)))\n\n\n(defn assoc-effect\n  [context key value]\n  (assoc-in context [:effects key] value))\n\n;; -- CoEffect Helpers  ---------------------------------------------------------------------------\n\n(defn get-coeffect\n  ([context]\n   (:coeffects context))\n  ([context key]\n   (get-in context [:coeffects key]))\n  ([context key not-found]\n   (get-in context [:coeffects key] not-found)))\n\n(defn assoc-coeffect\n  [context key value]\n  (assoc-in context [:coeffects key] value))\n\n(defn update-coeffect\n  [context key f & args]\n  (apply update-in context [:coeffects key] f args))\n\n;; -- Execute Interceptor Chain  ------------------------------------------------------------------\n\n\n(defn- invoke-interceptor-fn\n  [context interceptor direction]\n  (if-let [f (get interceptor direction)]\n    (f context)\n    context))\n\n\n(defn- invoke-interceptors\n  \"Loop over all interceptors, calling `direction` function on each,\n  threading the value of `context` through every call.\n\n  `direction` is one of `:before` or `:after`.\n\n  Each iteration, the next interceptor to process is obtained from\n  context's `:queue`. After they are processed, interceptors are popped\n  from `:queue` and added to `:stack`.\n\n  After sufficient iteration, `:queue` will be empty, and `:stack` will\n  contain all interceptors processed.\n\n  Returns updated `context`. Ie. the `context` which has been threaded\n  through all interceptor functions.\n\n  Generally speaking, an interceptor's `:before` function will (if present)\n  add to a `context's` `:coeffects`, while it's `:after` function\n  will modify the `context`'s `:effects`.  Very approximately.\n\n  But because all interceptor functions are given `context`, and can\n  return a modified version of it, the way is clear for an interceptor\n  to introspect the stack or queue, or even modify the queue\n  (add new interceptors via `enqueue`?). This is a very fluid arrangement.\"\n  ([context direction]\n   (loop [context context]\n     (let [queue (:queue context)]        ;; future interceptors\n       (if (empty? queue)\n         context\n         (let [interceptor (peek queue)   ;; next interceptor to call\n               stack (:stack context)]    ;; already completed interceptors\n           (recur (-> context\n                      (assoc :queue (pop queue)\n                             :stack (conj stack interceptor))\n                      (invoke-interceptor-fn interceptor direction)))))))))\n\n\n(defn enqueue\n  \"Add a collection of `interceptors` to the end of `context's` execution `:queue`.\n  Returns the updated `context`.\n\n  In an advanced case, this function could allow an interceptor to add new\n  interceptors to the `:queue` of a context.\"\n  [context interceptors]\n  (update context :queue\n          (fnil into empty-queue)\n          interceptors))\n\n\n(defn- context\n  \"Create a fresh context\"\n  ([event interceptors]\n  (-> {}\n      (assoc-coeffect :event event)\n      (enqueue interceptors)))\n  ([event interceptors db]      ;; only used in tests, probably a hack, remove ?  XXX\n   (-> (context event interceptors)\n       (assoc-coeffect :db db))))\n\n\n(defn- change-direction\n  \"Called on completion of `:before` processing, this function prepares/modifies\n   `context` for the backwards sweep of processing in which an interceptor\n   chain's `:after` fns are called.\n\n  At this point in processing, the `:queue` is empty and `:stack` holds all\n  the previously run interceptors. So this function enables the backwards walk\n  by priming `:queue` with what's currently in `:stack`\"\n  [context]\n  (-> context\n      (dissoc :queue)\n      (enqueue (:stack context))))\n\n\n(defn execute\n  \"Executes the given chain (coll) of interceptors.\n\n   Each interceptor has this form:\n       {:before  (fn [context] ...)     ;; returns possibly modified context\n        :after   (fn [context] ...)}    ;; `identity` would be a noop\n\n   Walks the queue of iterceptors from beginning to end, calling the\n   `:before` fn on each, then reverse direction and walk backwards,\n   calling the `:after` fn on each.\n\n   The last interceptor in the chain presumably wraps an event\n   handler fn. So the overall goal of the process is to \\\"handle\n   the given event\\\".\n\n   Thread a `context` through all calls. `context` has this form:\n\n     {:coeffects {:event [:a-query-id :some-param]\n                  :db    <original contents of app-db>}\n      :effects   {:db    <new value for app-db>\n                  :dispatch  [:an-event-id :param1]}\n      :queue     <a collection of further interceptors>\n      :stack     <a collection of interceptors already walked>}\n\n   `context` has `:coeffects` and `:effects` which, if this was a web\n   server, would be somewhat anologous to `request` and `response`\n   respectively.\n\n   `coeffects` will contain data like `event` and the initial\n   state of `db` -  the inputs required by the event handler\n   (sitting presumably on the end of the chain), while handler-returned\n   side effects are put into `:effects` including, but not limited to,\n   new values for `db`.\n\n   The first few interceptors in a chain will likely have `:before`\n   functions which \\\"prime\\\" the `context` by adding the event, and\n   the current state of app-db into `:coeffects`. But interceptors can\n   add whatever they want to `:coeffects` - perhaps the event handler needs\n   some information from localstore, or a random number, or access to\n   a DataScript connection.\n\n   Equally, some interceptors in the chain will have `:after` fn\n   which can process the side effects accumulated into `:effects`\n   including but, not limited to, updates to app-db.\n\n   Through both stages (before and after), `context` contains a `:queue`\n   of interceptors yet to be processed, and a `:stack` of interceptors\n   already done.  In advanced cases, these values can be modified by the\n   functions through which the context is threaded.\"\n  [event-v interceptors]\n  (trace/merge-trace!\n    {:tags {:interceptors interceptors}})\n  (-> (context event-v interceptors)\n      (invoke-interceptors :before)\n      change-direction\n      (invoke-interceptors :after)))\n"]}